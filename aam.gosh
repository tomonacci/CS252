(use gauche.generator)
(use gauche.sequence)
(use sxml.serializer)
(use srfi-1)
(use srfi-113)
(use util.match)

; pp = pretty-print
; In general, these procedures produce lists of SXML expressions.
(define (pp-expr expr)
  (match expr
    [(l (? symbol? x)) `((i ,(symbol->string x)) (sup ,l))]
    [(l (l- 'lambda #f x e) e-)
     (append `("(" (b (@ (style "font-family: monospace")) "let ") (i ,(symbol->string x)) " = ") (pp-expr e-) '(" " (tt (b "in")) " ") (pp-expr e) `(")" (sup ,l- "," ,l)))]
    [(l e0 e1) (append '("(") (pp-expr e0) '(" ") (pp-expr e1) `(")" (sup ,l)))]
    [(l 'lambda #f x e)
     (append `("(λ" (i ,(symbol->string x)) ". ") (pp-expr e) `(")" (sup ,l)))]
    [(l 'lambda a x e)
     (append `("(λ" (sup (tt ,(x->string a))) (i ,(symbol->string x)) ". ") (pp-expr e) `(")" (sup ,l)))]
    ))

(define (pp-sigma sigma :optional (abstracted? #f))
  (define (pp-storable storable)
    (match storable
      [(k e rho c)
       (append
        `((strong ,(symbol->string k)) "(")
        (pp-expr e)
        `(", " (tt ,(x->string rho)) ", " (tt ,(x->string c)) ")")
        )
       ]
      ['mt '((strong "mt"))]
      [(v . rho) `("(" ,@(pp-expr v) ", " (tt ,(x->string rho)) ")")]
      ))
  `((ul .
     ,(map
       (^p `(li (tt ,(x->string (car p)))
                " → "
                . ,(if abstracted?
                     (concatenate (intersperse '(", ") (map pp-storable (cdr p))))
                     (pp-storable (cdr p)))))
       sigma)))
  )

(define (pp-state state :optional (abstracted? #f))
  (match-let1 (e rho sigma a t) state
    `(ul
      (li . ,(pp-expr e))
      (li (tt ,(x->string rho)))
      (li . ,(pp-sigma sigma abstracted?))
      (li (tt ,(x->string a)))
      (li (tt ,(x->string t))))))

; generic< : any any -> boolean
; Defines "less-than" between objects a, b (possibly of different types) in the following manner:
;   1. a < b if a's type appears before b's type in the list type-predicates
;   2. When a, b has the same type, a < b is defined using procedures in the list type<.
;      The only tricky ones are:
;        - #t < #f for booleans
;        - symbols are compared with respect to their string values
;        - pairs are sorted in the dictionary order, where each "letters" are compared by generic<
; Equality is always by equal?.
; By applying sort-by with this procedure, lists can be canonicalized (in an admittedly fairly arbitrary way).
(define (generic< a b)
  (define type-predicates (list undefined? boolean? integer? symbol? string? null? pair?))
  (define type<
    (list
     #f ; undefined?
     (^(a b) (and a (not b))) ; boolean?
     < ; integer?
     (^(a b) (string<? (symbol->string a) (symbol->string b))) ; symbol?
     string<? ; string?
     #f ; null?
     (^(a b) ; pair?
       (cond [(equal? (car a) (car b))
              (generic< (cdr a) (cdr b))]
             [(generic< (car a) (car b)) #t]
             [else #f]))
     ))
  (define (type-index x)
    (find-index (^p (p x)) type-predicates))
  (let ([i (type-index a)]
        [j (type-index b)])
    (or (< i j)
        (and (= i j)
             (not (equal? a b))
             ((list-ref type< i) a b)))))

; sorted key-value list update
(define (skvl-update skvl kv kv->key adjoin)
  (let loop ([result ()] [skvl skvl])
    (cond [(null? skvl)
           (reverse! result (cons kv skvl))]
          [(equal? (kv->key kv) (kv->key (car skvl)))
           (reverse! result (cons (adjoin (car skvl) kv) (cdr skvl)))]
          [(generic< (kv->key kv) (kv->key (car skvl)))
           (reverse! result (cons kv skvl))]
          [else (loop (cons (car skvl) result) (cdr skvl))])))

; sorted list update
; Inserts e in a sorted (w.r.t. generic<) list if it is absent.
(define (sl-update sl e)
  (skvl-update sl e identity (^(x _) x)))

; alist with singular values (like environments and concrete stores)
(define (assoc-update k v alist)
  (skvl-update alist (cons k v) car (^(_ p) p)))

; sigma is assumed to be an alist with sorted lists of storables as values.
(define (update-sigma a storable sigma)
  (skvl-update sigma (cons a (list storable)) car
   (^(a _) (cons (car a) (sl-update (cdr a) storable)))))

; Is a-abs reachable in sigma from a-kappa?
; If abstracted? is #t, sigma's values are thought to be lists of storables.
(define (reachable? sigma a-kappa a-abs :optional (abstracted? #f))
  (or (equal? a-kappa a-abs)
      (any
       (match-lambda
         [('ar _ _ a) (reachable? sigma a a-abs abstracted?)]
         [('fn _ _ a) (reachable? sigma a a-abs abstracted?)]
         [else #f]
         )
       ((if abstracted? identity list) (assoc-ref sigma a-kappa)))))

; Concrete reduction relation (function). Returns two values: the rule used and the next state.
; When you design tick and alloc, you may not include #f in Addr.
(define (step state tick alloc)
  (define (u) (tick state))
  (match state
    [((l (? symbol? x)) rho sigma a t)
     (receive (v rho-) (car+cdr (assoc-ref sigma (assoc-ref rho x)))
       (values "#1" (list v rho- sigma a (u))))]
    [((l e0 e1) rho sigma a t)
     (let1 b (alloc state)
       (values "#2" (list e0 rho (assoc-update b (list 'ar e1 rho a) sigma) b (u))))]
    [(v rho sigma a t)
     (match (assoc-ref sigma a)
       [('ar e rho- c)
        ; Escape analysis!
        (match-let1 (l 'lambda a-abs _ _) v
          (when a-abs
            (format (standard-error-port) "~d ~a\n" l (if (reachable? sigma c a-abs) "is contained" "escapes"))))
        (let1 b (alloc state)
          (values "#3" (list e rho- (assoc-update b (list 'fn v rho c) sigma) b (u))))]
       [('fn (_ 'lambda _ x-kappa e-kappa) rho- c)
        (let1 b (alloc state)
          (receive [rule w] (match v
                              [(l 'lambda #f x e)
                               (values "#4a" (list l 'lambda c x e))]
                              [(_ 'lambda _ _ _)
                               (values "#4b" v)]
                              )
            (values rule (list e-kappa (assoc-update x-kappa b rho-) (assoc-update b (cons w rho) sigma) c (u)))))]
       [else (values #f ())]
       )]
    ))

; Abstract reduction relation. Returns the list of (rule . next-state) pairs.
(define (step^ state tick^ alloc^)
  (match state
    [((l (? symbol? x)) rho sigma a t)
     (append-map
      (^k (append-map
           (match-lambda
             ['mt ()]
             [('ar _ _ _) ()]
             [('fn _ _ _) ()]
             [(v . rho-) (list (cons "#1" (list v rho- sigma a (tick^ state k))))]
             )
           (assoc-ref sigma (assoc-ref rho x))))
      (assoc-ref sigma a))]
    [((l e0 e1) rho sigma a t)
     (append-map
      (^k (let1 b (alloc^ state k)
            (list (cons "#2" (list e0 rho (update-sigma b (list 'ar e1 rho a) sigma) b (tick^ state k))))))
      (assoc-ref sigma a))]
    [(v rho sigma a t)
     (append-map
      (^k (match k
            [('ar e rho- c)
             ; Escape analysis!
             (match-let1 (l 'lambda a-abs _ _) v
               (when a-abs
                 (format (standard-error-port) "~d ~a\n" l (if (reachable? sigma c a-abs #t) "may be contained" "definitely escapes"))))
             (let1 b (alloc^ state k)
               (list (cons "#3" (list e rho- (update-sigma b (list 'fn v rho c) sigma) b (tick^ state k)))))]
            [('fn (l 'lambda a-abs x e) rho- c)
             (let1 b (alloc^ state k)
               (receive [rule w] (match v
                                   [(l 'lambda #f x-kappa e-kappa)
                                    (values "#4a" (list l 'lambda c x-kappa e-kappa))]
                                   [(l 'lambda a-kappa x-kappa e-kappa)
                                    (values "#4b" v)])
                 (list (cons rule (list e (assoc-update x b rho-) (update-sigma b (cons w rho) sigma) c (tick^ state k))))))]
            [else ()]
            ))
      (assoc-ref sigma a))]
    ))

; Labels human-friendly expr. Additionally desugars let.
(define (label-expr expr)
  (define label (generate (^y (let loop ([i 1]) (y i) (loop (+ i 1))))))
  (let rec ((expr expr))
    (match expr
      [('let x e1 e2) `(,(label) (,(label) lambda #f ,x ,(rec e2)) ,(rec e1))]
      [('lambda x e) `(,(label) lambda #f ,x ,(rec e))]
      [(e1 e2) `(,(label) ,(rec e1) ,(rec e2))]
      [(? symbol? x) `(,(label) ,x)]
      )))

; Garbage collection. Returns the garbage free version of the state.
(define (cleanse state)
  (match-let1 (e rho sigma a t) state
    (let* ([seen (list->set 'equal? (cons a (map cdr rho)))]
           [todo (set->list seen)]
           )
      (until (null? todo)
        (for-each
         (^a (set! seen (values-ref (set-search! seen a (^(insert _) (push! todo a) (insert #f)) (^ _ seen)) 0)))
         (match (assoc-ref sigma (pop! todo))
           ['mt ()]
           [((or 'ar 'fn) _ rho a) (cons a (map cdr rho))]
           [(_ . rho) (map cdr rho)]
           )))
      (list e rho (filter (^p (set-contains? seen (car p))) sigma) a t))))

; Prints out HTML picturing a concrete machine's operation.
(define (step-through expr inj tick alloc)
  (define (pp state)
    ;(print state)
    ;(print (pp-state state))
    (print (srl:sxml->html (pp-state state)))
    )
  (print "<html xmlns=\"http://www.w3.org/1999/xhtml\">")
  (print "<head><style>body { margin: 0; padding: 2em; }</style></head>")
  (print "<body>")
  (let loop ((state (inj expr)))
    (pp state)
    (receive (rule state-) (step state tick alloc)
      (when rule
        (set! state- (cleanse state-))
        (print rule)
        (loop state-)
        )))
  (print "</body>")
  (print "</html>")
  )

; Prints out HTML picturing an abstract machine's operation.
; Each state is assigned an unique number.
; At the end of the page, there is a Graphviz-compatible graph description using state numbers as nodes and edges labeled by transitioning rules.
(define (step-through^ expr inj^ tick^ alloc^)
  (define initial-state (cons (inj^ expr) 0))
  (let loop ([seen (hash-table 'equal? initial-state)]
             [todo (list initial-state)]
             [edges ()]
             )
    (if (null? todo)
      (begin
        (print "<html xmlns=\"http://www.w3.org/1999/xhtml\">")
        (print "<head><style>body { margin: 0; padding: 2em; }</style></head>")
        (print "<body>")
        #|
        (for-each
         (^p (receive [state n] (car+cdr p)
               (print n)
               (print state)))
         (sort-by! (hash-table->alist seen) cdr))
        |#
        (for-each
         (^p (receive [state n] (car+cdr p)
               (print n)
               (print (srl:sxml->html (pp-state state #t)))))
         (sort-by! (hash-table->alist seen) cdr))
        (print "<pre>")
        (for-each
         (match-lambda
           [(rule n n-)
            (format #t "~s -> ~s [label=\"~a\"];\n" n n- rule)]
           )
         edges)
        (print "</pre>")
        (print "</body>")
        (print "</html>")
        )
      (match-let1 ((state . n) . todo) todo
        (for-each
         (^p (receive [rule state-] (car+cdr p)
               (let1 n- (if (hash-table-exists? seen state-)
                          (hash-table-get seen state-)
                          (rlet1 n- (hash-table-num-entries seen)
                            (hash-table-put! seen state- n-)
                            (when (zero? (remainder n- 100))
                              #?=n-)
                            (push! todo (cons state- n-))))
                 (push! edges (list rule n n-)))))
         (step^ state tick^ alloc^))
        (loop seen todo edges)))))

(define (main args)
  ; tCESK*
  (define (inj expr)
    `(,(label-expr expr) () ((0 . mt)) 0 1))
  (define (tick state)
    (match state
      [(_ _ _ _ t) (+ t 1)]))
  (define (alloc state)
    (match state
      [(_ _ _ _ t) t]))

  ; concrete (k-)CFA
  (define (cfa-inj expr)
    `(,(label-expr expr) () (((#f ()) . mt)) (#f ()) (#f ())))
  (define (cfa-tick state)
    (match state
      [((l x) _ _ _ t) t]
      [((l _ _) _ _ _ (_ delta)) (list l delta)]
      [(_ _ sigma a (l delta))
       (match (assoc-ref sigma a)
         [('ar _ _ _) (list l delta)]
         [('fn _ _ _) (list #f (if l (cons l delta) delta))]
         )]
      ))
  (define (cfa-alloc state)
    (match state
      [((_ (l . _) _) _ _ _ (_ delta)) (list l delta)]
      [(_ _ sigma a (_ delta))
       (match (assoc-ref sigma a)
         [('ar (l . _) _ _) (list l delta)]
         [('fn (_ 'lambda _ x _) _ _) (list x delta)]
         )]
      ))

  ; Finitization by circular time. Really bad idea.
  (define end-of-the-time 2)
  (define (inj^ expr)
    `(,(label-expr expr) () ((0 . (mt))) 0 ,(remainder 1 end-of-the-time)))
  (define (tick^ state kappa)
    (match state
      [(_ _ _ _ t) (remainder (+ t 1) end-of-the-time)]))
  (define (alloc^ state kappa)
    (match state
      [(_ _ _ _ t) t]))

  ; abstract k-CFA
  (define k 0)
  (define (cfa-inj^ expr)
    `(,(label-expr expr) () (((#f ()) . (mt))) (#f ()) (#f ())))
  (define (cfa-tick^ state kappa)
    (match state
      [((l x) _ _ _ t) t]
      [((l _ _) _ _ _ (_ delta)) (list l delta)]
      [(_ _ sigma a (l delta))
       (match kappa
         [('ar _ _ _) (list l delta)]
         [('fn _ _ _) (list #f (take* (if l (cons l delta) delta) k))]
         )]
      ))
  (define (cfa-alloc^ state kappa)
    (match state
      [((_ (l . _) _) _ _ _ (_ delta)) (list l delta)]
      [(_ _ sigma a (_ delta))
       (match kappa
         [('ar (l . _) _ _) (list l delta)]
         [('fn (_ 'lambda _ x _) _ _) (list x delta)]
         )]
      ))

  ;(step-through^ '((lambda x x) (lambda y y)) cfa-inj^ cfa-tick^ cfa-alloc^)
  ;(step-through^ '((lambda x x) (lambda y y)) inj^ tick^ alloc^)
  ;(step-through^ '(((lambda f (lambda g (g f))) (lambda x x)) (lambda y (y (lambda z z)))) cfa-inj^ cfa-tick^ cfa-alloc^)
  ;(step-through^ '(((lambda f (lambda g (g f))) (lambda x x)) (lambda y (y (lambda z z)))) inj^ tick^ alloc^)
  ;(step-through '(((lambda f (lambda g (g f))) (lambda x x)) (lambda y (y (lambda z z)))) inj tick alloc)
  ;(step-through '((lambda f ((lambda w (w f)) (lambda y (lambda z z)))) (lambda x x)) inj tick alloc)
  (step-through '(let f (lambda x x)
                   (let w (lambda y (lambda z z))
                     (w f)))
                inj tick alloc)
  ;(step-through '(((lambda f (f (lambda x x))) (lambda y y)) (lambda z z)) inj tick alloc)
  ;(step-through '((lambda x x) (lambda y y)) tick alloc)
  #|
  (step-through '((lambda id
                    ((lambda w (id (lambda z z)))
                     (id (lambda y y))))
                  (lambda x x))
                inj tick alloc)
  (step-through^ '((lambda id
                     ((lambda w (id (lambda z z)))
                      (id (lambda y y))))
                   (lambda x x))
                 inj^ tick^ alloc^)
  (step-through '((lambda id
                    ((lambda w (id (lambda z z)))
                     (id (lambda y y))))
                  (lambda x x))
                cfa-inj cfa-tick cfa-alloc)
  (step-through^ '((lambda id
                     ((lambda w (id (lambda z z)))
                      (id (lambda y y))))
                   (lambda x x))
                 cfa-inj^ cfa-tick^ cfa-alloc^)
  |#
  ;#?=(sort '(0 8 7 symbol lambda "tick" (a . b) #f #f (u . a) #t (a b 0) (0 u c) #f) generic<)
  ;#?=(sort '((#f ()) (2 ()) (13 ()) (id ()) (4 (1))) generic<)
  ;(step-through '((lambda f (f f)) (lambda x x)) tick alloc)
  ;(step-through '((lambda f (f (f f))) (lambda x x)) tick alloc)
  0)
